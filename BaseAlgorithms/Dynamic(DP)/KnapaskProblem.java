package Algorithm;



/**
 * @author LZH.create
 *    分治法  --> 动态规划    
 */
public class KnapaskProblem {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		 int [] w = {1,4,3} ;  // 三件商品的质量
		 
		 int[] val = {1500, 3000, 2000}; //物品的价值 这里val[i] 就是前面的v[i]
			int m = 4; //背包的容量
			int n = val.length; //物品的个数
			
			
			
			
			//v[i][j] 表示在前i个物品中能够装入容量为j的背包中的最大价值
			int[][] v = new int[n+1][m+1] ;    // 其中的 1 为 0 行
 			
			
			//为了记录放入商品的情况，我们定一个二维数组
			int[][] path = new int[n+1][m+1];
			
			//初始化第一行和第一列, 这里在本程序中，可以不去处理，因为默认就是0
			for(int i = 0; i < v.length; i++) {
				v[i][0] = 0; 
			}
			for(int i=0; i < v[0].length; i++) {
				v[0][i] = 0; 
			}
			

			// 动态规划 
			for(int i = 1; i < v.length; i++) {  
				for(int j=1; j < v[0].length; j++) { 
					//公式
					if(w[i-1]> j) { // 因为我们程序i 是从1开始的，因此原来公式中的 w[i] 修改成 w[i-1]
						v[i][j]=v[i-1][j];
					} else {
				
						if(v[i - 1][j] < val[i - 1] + v[i - 1][j - w[i - 1]]) {
							v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
							//把当前的情况记录到path
							path[i][j] = 1;     // 把放过东西的记录
						} else {
							v[i][j] = v[i - 1][j];
						}
						
					}
				}
			}
			
			//输出一下v 看看目前的情况
			for(int i =0; i < v.length;i++) {
				for(int j = 0; j < v[0].length;j++) {
					System.out.print(v[i][j] + " ");
				}
				System.out.println();
			}
			
			System.out.println("============================");

		
			int i = path.length - 1; //行的最大下标
			int j = path[0].length - 1;  //列的最大下标
			
			while(i > 0 && j > 0 ) { //从path的最后开始找
				if(path[i][j] == 1) {
					System.out.printf("第%d个商品放入到背包\n", i); 
					j -= w[i-1]; //w[i-1]     从后面开始  调整背包容量
				}
				i--;
			}
			
	}

}
